import { useRef, useState, useEffect, useCallback, useMemo, useDebugValue } from 'react';
import { a as useNow, u as useUtils } from './dimensions-91c32fe6.js';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';

function useOpenState(_ref) {
  var open = _ref.open,
      onOpen = _ref.onOpen,
      onClose = _ref.onClose;
  var isControllingOpenProp = useRef(typeof open === 'boolean').current;

  var _React$useState = useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      _open = _React$useState2[0],
      _setIsOpen = _React$useState2[1]; // It is required to update inner state in useEffect in order to avoid situation when
  // Our component is not mounted yet, but `open` state is set to `true` (e.g. initially opened)


  useEffect(function () {
    if (isControllingOpenProp) {
      if (typeof open !== 'boolean') {
        throw new Error('You must not mix controlling and uncontrolled mode for `open` prop');
      }

      _setIsOpen(open);
    }
  }, [isControllingOpenProp, open]);
  var setIsOpen = useCallback(function (newIsOpen) {
    if (!isControllingOpenProp) {
      _setIsOpen(newIsOpen);
    }

    return newIsOpen ? onOpen && onOpen() : onClose && onClose();
  }, [isControllingOpenProp, onOpen, onClose]);
  return {
    isOpen: _open,
    setIsOpen: setIsOpen
  };
}

var FORCE_FINISH_PICKER = Symbol('Force closing picker, useful for accessibility');
function usePickerState(props, valueManager) {
  var autoOk = props.autoOk,
      inputFormat = props.inputFormat,
      disabled = props.disabled,
      readOnly = props.readOnly,
      onAccept = props.onAccept,
      onChange = props.onChange,
      value = props.value;

  if (!inputFormat) {
    throw new Error('inputFormat prop is required');
  }

  var now = useNow();
  var utils = useUtils();
  var date = valueManager.parseInput(now, utils, props);

  var _useState = useState(date),
      _useState2 = _slicedToArray(_useState, 2),
      pickerDate = _useState2[0],
      setPickerDate = _useState2[1]; // Mobile keyboard view is a special case.
  // When it's open picker should work like closed, cause we are just showing text field


  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isMobileKeyboardViewOpen = _useState4[0],
      setMobileKeyboardViewOpen = _useState4[1];

  var _useOpenState = useOpenState(props),
      isOpen = _useOpenState.isOpen,
      setIsOpen = _useOpenState.setIsOpen;

  useEffect(function () {
    setPickerDate(function (currentPickerDate) {
      if (!valueManager.areValuesEqual(currentPickerDate, date)) {
        return date;
      }

      return currentPickerDate;
    }); // We need to react only on value change, because `date` could potentially return new Date() on each render
  }, [value, utils]); // eslint-disable-line

  var acceptDate = useCallback(function (acceptedDate, needClosePicker) {
    onChange(acceptedDate);

    if (needClosePicker) {
      setIsOpen(false);

      if (onAccept) {
        onAccept(acceptedDate);
      }
    }
  }, [onAccept, onChange, setIsOpen]);
  var wrapperProps = useMemo(function () {
    return {
      open: isOpen,
      onClear: function onClear() {
        return acceptDate(valueManager.emptyValue, true);
      },
      onAccept: function onAccept() {
        return acceptDate(pickerDate, true);
      },
      onDismiss: function onDismiss() {
        return setIsOpen(false);
      },
      onSetToday: function onSetToday() {
        // TODO FIX ME
        setPickerDate(now);
        acceptDate(now, Boolean(autoOk));
      }
    };
  }, [acceptDate, autoOk, isOpen, now, pickerDate, setIsOpen, valueManager.emptyValue]);
  var pickerProps = useMemo(function () {
    return {
      date: pickerDate,
      isMobileKeyboardViewOpen: isMobileKeyboardViewOpen,
      toggleMobileKeyboardView: function toggleMobileKeyboardView() {
        if (!isMobileKeyboardViewOpen) {
          // accept any partial input done by user
          setPickerDate(pickerDate);
        }

        setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen);
      },
      onDateChange: function onDateChange(newDate, currentVariant) {
        var isFinish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        setPickerDate(newDate);
        var isFinishing = typeof isFinish === 'boolean' ? isFinish : isFinish === FORCE_FINISH_PICKER;

        if (isFinishing) {
          var autoAcceptRequested = Boolean(autoOk) || isFinish === FORCE_FINISH_PICKER;

          if (currentVariant === 'mobile' && autoAcceptRequested) {
            acceptDate(newDate, true);
          }

          if (currentVariant !== 'mobile') {
            acceptDate(newDate, autoAcceptRequested);
          }
        }
      }
    };
  }, [acceptDate, autoOk, isMobileKeyboardViewOpen, pickerDate]);
  var inputProps = useMemo(function () {
    return {
      onChange: onChange,
      inputFormat: inputFormat,
      open: isOpen,
      rawValue: value,
      openPicker: function openPicker() {
        return !readOnly && !disabled && setIsOpen(true);
      }
    };
  }, [onChange, inputFormat, isOpen, value, readOnly, disabled, setIsOpen]);
  var pickerState = {
    pickerProps: pickerProps,
    inputProps: inputProps,
    wrapperProps: wrapperProps
  };
  useDebugValue(pickerState, function () {
    return {
      MuiPickerState: {
        pickerDate: pickerDate,
        parsedDate: date,
        other: pickerState
      }
    };
  });
  return pickerState;
}

export { FORCE_FINISH_PICKER as F, usePickerState as u };
//# sourceMappingURL=usePickerState-1c348703.js.map
