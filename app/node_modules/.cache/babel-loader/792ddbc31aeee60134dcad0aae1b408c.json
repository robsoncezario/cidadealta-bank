{"ast":null,"code":"import { useRef, useState, useEffect, useCallback, useMemo, useDebugValue } from 'react';\nimport { a as useNow, u as useUtils } from './dimensions-91c32fe6.js';\nimport _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';\n\nfunction useOpenState(_ref) {\n  var open = _ref.open,\n      onOpen = _ref.onOpen,\n      onClose = _ref.onClose;\n  var isControllingOpenProp = useRef(typeof open === 'boolean').current;\n\n  var _React$useState = useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      _open = _React$useState2[0],\n      _setIsOpen = _React$useState2[1]; // It is required to update inner state in useEffect in order to avoid situation when\n  // Our component is not mounted yet, but `open` state is set to `true` (e.g. initially opened)\n\n\n  useEffect(function () {\n    if (isControllingOpenProp) {\n      if (typeof open !== 'boolean') {\n        throw new Error('You must not mix controlling and uncontrolled mode for `open` prop');\n      }\n\n      _setIsOpen(open);\n    }\n  }, [isControllingOpenProp, open]);\n  var setIsOpen = useCallback(function (newIsOpen) {\n    if (!isControllingOpenProp) {\n      _setIsOpen(newIsOpen);\n    }\n\n    return newIsOpen ? onOpen && onOpen() : onClose && onClose();\n  }, [isControllingOpenProp, onOpen, onClose]);\n  return {\n    isOpen: _open,\n    setIsOpen: setIsOpen\n  };\n}\n\nvar FORCE_FINISH_PICKER = Symbol('Force closing picker, useful for accessibility');\n\nfunction usePickerState(props, valueManager) {\n  var autoOk = props.autoOk,\n      inputFormat = props.inputFormat,\n      disabled = props.disabled,\n      readOnly = props.readOnly,\n      onAccept = props.onAccept,\n      onChange = props.onChange,\n      value = props.value;\n\n  if (!inputFormat) {\n    throw new Error('inputFormat prop is required');\n  }\n\n  var now = useNow();\n  var utils = useUtils();\n  var date = valueManager.parseInput(now, utils, props);\n\n  var _useState = useState(date),\n      _useState2 = _slicedToArray(_useState, 2),\n      pickerDate = _useState2[0],\n      setPickerDate = _useState2[1]; // Mobile keyboard view is a special case.\n  // When it's open picker should work like closed, cause we are just showing text field\n\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isMobileKeyboardViewOpen = _useState4[0],\n      setMobileKeyboardViewOpen = _useState4[1];\n\n  var _useOpenState = useOpenState(props),\n      isOpen = _useOpenState.isOpen,\n      setIsOpen = _useOpenState.setIsOpen;\n\n  useEffect(function () {\n    setPickerDate(function (currentPickerDate) {\n      if (!valueManager.areValuesEqual(currentPickerDate, date)) {\n        return date;\n      }\n\n      return currentPickerDate;\n    }); // We need to react only on value change, because `date` could potentially return new Date() on each render\n  }, [value, utils]); // eslint-disable-line\n\n  var acceptDate = useCallback(function (acceptedDate, needClosePicker) {\n    onChange(acceptedDate);\n\n    if (needClosePicker) {\n      setIsOpen(false);\n\n      if (onAccept) {\n        onAccept(acceptedDate);\n      }\n    }\n  }, [onAccept, onChange, setIsOpen]);\n  var wrapperProps = useMemo(function () {\n    return {\n      open: isOpen,\n      onClear: function onClear() {\n        return acceptDate(valueManager.emptyValue, true);\n      },\n      onAccept: function onAccept() {\n        return acceptDate(pickerDate, true);\n      },\n      onDismiss: function onDismiss() {\n        return setIsOpen(false);\n      },\n      onSetToday: function onSetToday() {\n        // TODO FIX ME\n        setPickerDate(now);\n        acceptDate(now, Boolean(autoOk));\n      }\n    };\n  }, [acceptDate, autoOk, isOpen, now, pickerDate, setIsOpen, valueManager.emptyValue]);\n  var pickerProps = useMemo(function () {\n    return {\n      date: pickerDate,\n      isMobileKeyboardViewOpen: isMobileKeyboardViewOpen,\n      toggleMobileKeyboardView: function toggleMobileKeyboardView() {\n        if (!isMobileKeyboardViewOpen) {\n          // accept any partial input done by user\n          setPickerDate(pickerDate);\n        }\n\n        setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen);\n      },\n      onDateChange: function onDateChange(newDate, currentVariant) {\n        var isFinish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        setPickerDate(newDate);\n        var isFinishing = typeof isFinish === 'boolean' ? isFinish : isFinish === FORCE_FINISH_PICKER;\n\n        if (isFinishing) {\n          var autoAcceptRequested = Boolean(autoOk) || isFinish === FORCE_FINISH_PICKER;\n\n          if (currentVariant === 'mobile' && autoAcceptRequested) {\n            acceptDate(newDate, true);\n          }\n\n          if (currentVariant !== 'mobile') {\n            acceptDate(newDate, autoAcceptRequested);\n          }\n        }\n      }\n    };\n  }, [acceptDate, autoOk, isMobileKeyboardViewOpen, pickerDate]);\n  var inputProps = useMemo(function () {\n    return {\n      onChange: onChange,\n      inputFormat: inputFormat,\n      open: isOpen,\n      rawValue: value,\n      openPicker: function openPicker() {\n        return !readOnly && !disabled && setIsOpen(true);\n      }\n    };\n  }, [onChange, inputFormat, isOpen, value, readOnly, disabled, setIsOpen]);\n  var pickerState = {\n    pickerProps: pickerProps,\n    inputProps: inputProps,\n    wrapperProps: wrapperProps\n  };\n  useDebugValue(pickerState, function () {\n    return {\n      MuiPickerState: {\n        pickerDate: pickerDate,\n        parsedDate: date,\n        other: pickerState\n      }\n    };\n  });\n  return pickerState;\n}\n\nexport { FORCE_FINISH_PICKER as F, usePickerState as u };","map":{"version":3,"sources":["../src/_shared/hooks/useOpenState.ts","../src/_shared/hooks/usePickerState.ts"],"names":["open","onOpen","onClose","isControllingOpenProp","React","_open","_setIsOpen","setIsOpen","newIsOpen","isOpen","FORCE_FINISH_PICKER","Symbol","autoOk","inputFormat","disabled","readOnly","onAccept","onChange","value","props","now","useNow","utils","useUtils","date","valueManager","pickerDate","setPickerDate","useState","isMobileKeyboardViewOpen","setMobileKeyboardViewOpen","useOpenState","useEffect","acceptDate","useCallback","wrapperProps","useMemo","onClear","onDismiss","onSetToday","Boolean","pickerProps","toggleMobileKeyboardView","onDateChange","isFinish","isFinishing","autoAcceptRequested","currentVariant","inputProps","rawValue","openPicker","pickerState","useDebugValue","MuiPickerState","parsedDate","other"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { BasePickerProps } from '../../typings/BasePicker';\n\nexport function useOpenState({ open, onOpen, onClose }: BasePickerProps<any, any>) {\n  const isControllingOpenProp = React.useRef(typeof open === 'boolean').current;\n  const [_open, _setIsOpen] = React.useState(false);\n\n  // It is required to update inner state in useEffect in order to avoid situation when\n  // Our component is not mounted yet, but `open` state is set to `true` (e.g. initially opened)\n  React.useEffect(() => {\n    if (isControllingOpenProp) {\n      if (typeof open !== 'boolean') {\n        throw new Error('You must not mix controlling and uncontrolled mode for `open` prop');\n      }\n\n      _setIsOpen(open);\n    }\n  }, [isControllingOpenProp, open]);\n\n  const setIsOpen = React.useCallback(\n    (newIsOpen: boolean) => {\n      if (!isControllingOpenProp) {\n        _setIsOpen(newIsOpen);\n      }\n\n      return newIsOpen ? onOpen && onOpen() : onClose && onClose();\n    },\n    [isControllingOpenProp, onOpen, onClose]\n  );\n\n  return { isOpen: _open, setIsOpen };\n}\n","import { useOpenState } from './useOpenState';\nimport { WrapperVariant } from '../../wrappers/Wrapper';\nimport { BasePickerProps } from '../../typings/BasePicker';\nimport { MaterialUiPickersDate } from '../../typings/date';\nimport { useUtils, useNow, MuiPickersAdapter } from './useUtils';\nimport { useCallback, useDebugValue, useEffect, useMemo, useState } from 'react';\n\nexport const FORCE_FINISH_PICKER = Symbol('Force closing picker, useful for accessibility');\n\nexport function usePickerState<TInput, TDateValue>(\n  props: BasePickerProps<TInput, TDateValue>,\n  valueManager: {\n    parseInput: (\n      now: MaterialUiPickersDate,\n      utils: MuiPickersAdapter,\n      props: BasePickerProps<TInput, TDateValue>\n    ) => TDateValue;\n    emptyValue: TDateValue;\n    areValuesEqual: (valueLeft: TDateValue, valueRight: TDateValue) => boolean;\n  }\n) {\n  const { autoOk, inputFormat, disabled, readOnly, onAccept, onChange, value } = props;\n\n  if (!inputFormat) {\n    throw new Error('inputFormat prop is required');\n  }\n\n  const now = useNow();\n  const utils = useUtils();\n  const date = valueManager.parseInput(now, utils, props);\n  const [pickerDate, setPickerDate] = useState(date);\n\n  // Mobile keyboard view is a special case.\n  // When it's open picker should work like closed, cause we are just showing text field\n  const [isMobileKeyboardViewOpen, setMobileKeyboardViewOpen] = useState(false);\n  const { isOpen, setIsOpen } = useOpenState(props);\n\n  useEffect(() => {\n    setPickerDate(currentPickerDate => {\n      if (!valueManager.areValuesEqual(currentPickerDate, date)) {\n        return date;\n      }\n\n      return currentPickerDate;\n    });\n    // We need to react only on value change, because `date` could potentially return new Date() on each render\n  }, [value, utils]); // eslint-disable-line\n\n  const acceptDate = useCallback(\n    (acceptedDate: TDateValue, needClosePicker: boolean) => {\n      onChange(acceptedDate);\n\n      if (needClosePicker) {\n        setIsOpen(false);\n\n        if (onAccept) {\n          onAccept(acceptedDate);\n        }\n      }\n    },\n    [onAccept, onChange, setIsOpen]\n  );\n\n  const wrapperProps = useMemo(\n    () => ({\n      open: isOpen,\n      onClear: () => acceptDate(valueManager.emptyValue, true),\n      onAccept: () => acceptDate(pickerDate, true),\n      onDismiss: () => setIsOpen(false),\n      onSetToday: () => {\n        // TODO FIX ME\n        setPickerDate(now as any);\n        acceptDate(now as any, Boolean(autoOk));\n      },\n    }),\n    [acceptDate, autoOk, isOpen, now, pickerDate, setIsOpen, valueManager.emptyValue]\n  );\n\n  const pickerProps = useMemo(\n    () => ({\n      date: pickerDate,\n      isMobileKeyboardViewOpen,\n      toggleMobileKeyboardView: () => {\n        if (!isMobileKeyboardViewOpen) {\n          // accept any partial input done by user\n          setPickerDate(pickerDate);\n        }\n\n        setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen);\n      },\n      onDateChange: (\n        newDate: TDateValue,\n        currentVariant: WrapperVariant,\n        isFinish: boolean | symbol = true\n      ) => {\n        setPickerDate(newDate);\n        const isFinishing =\n          typeof isFinish === 'boolean' ? isFinish : isFinish === FORCE_FINISH_PICKER;\n\n        if (isFinishing) {\n          const autoAcceptRequested = Boolean(autoOk) || isFinish === FORCE_FINISH_PICKER;\n          if (currentVariant === 'mobile' && autoAcceptRequested) {\n            acceptDate(newDate, true);\n          }\n\n          if (currentVariant !== 'mobile') {\n            acceptDate(newDate, autoAcceptRequested);\n          }\n        }\n      },\n    }),\n    [acceptDate, autoOk, isMobileKeyboardViewOpen, pickerDate]\n  );\n\n  const inputProps = useMemo(\n    () => ({\n      onChange,\n      inputFormat,\n      open: isOpen,\n      rawValue: value,\n      openPicker: () => !readOnly && !disabled && setIsOpen(true),\n    }),\n    [onChange, inputFormat, isOpen, value, readOnly, disabled, setIsOpen]\n  );\n\n  const pickerState = { pickerProps, inputProps, wrapperProps };\n  useDebugValue(pickerState, () => ({\n    MuiPickerState: {\n      pickerDate,\n      parsedDate: date,\n      other: pickerState,\n    },\n  }));\n\n  return pickerState;\n}\n"]},"metadata":{},"sourceType":"module"}